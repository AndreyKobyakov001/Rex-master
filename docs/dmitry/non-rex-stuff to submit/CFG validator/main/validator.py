"""
This script provides an API for checking whether a particular dataflow path is actually feasible
with respect to the program's control flow.

For instance, the dataflow "a -> b -> c" in the following function is actually a false positive.
See the tests for more examples of valid and invalid dataflows.
void foo() {
    int a, b, c;
    c = b;
    b = a;
}

The validator relies on the graph structure generated by `preprocess.cypher`.

Here is an overview of the algorithm used to validate paths:

A path is a sequence of `varWriteNode` nodes. Each node represents a `varWrite` relationship in the code,
and so is linked to two variables: `a -link-> varWriteNode -link-> b === a -varWrite-> b`
Any two consecutive `varWriteNode` nodes represent a dataflow across 3 variables:
`a -link-> varWriteNode -link-> b -link-> varWriteNode -link-> c === a -varWrite-> b -varWrite-> c`

Each `varWriteNode` node is connected directly to all CFG nodes and to all function nodes that contain the `varWrite`.


For each varWriteNode along the path, the locations of the varWrite may be all over the place.
    n1:{ rel: a -> b, locations: {f1: [f1's CFGs containing the relation], f5: [f5's CFGs containing the relation], f6: [ ... ]}},
    n2:{ rel: b -> c, locations: {f3: [ ... ], f5: [ ... ], f9: [ ... ]}},
    n3:{ rel: c -> d, locations: {f4: [ ... ], f7: [ ... ], f8: [ ... ]}},
    n4:{ rel: d -> e, locations: {f1: [ ... ], f6: [ ... ]}}

The point of the algorithm is to find a valid sequence of function calls and returns that link the relationships together, and a valid path
through each function's CFG that links these relationships to each other and to any of the calls/return nodes. An example is probably better:

    Let's say that for the above path, there exists a valid control flow in the code:
    f4() {
        c -> d;
    }
    f3() {
        b -> c;
    }
    f2() {
        f3();
        f4();
    }
    f1() {
        a -> b
        ...
        f2();
        ...
        d -> e;
    }

    Then the minimal set of assertions needed is:
        f1: {a -> b} -> {f2()} -> {d -> e}
            - for the relationship `a -varWrite-> b`, take the set X of all CFG blocks under `f1()` which contain this relationship
            - for the relationship `f1 -calls-> f2`, take the set Y of all CFG blocks under `f1()` which contain this relationship
            - for the relationship `d -varWrite-> e`, take the Z set of all CFG blocks under `f1()` which contain this relationship
            - There must exist CFG nodes `x in X, y in Y, z in Z` such that there exists a path `x -->* y -->* z` through `f1()`'s CFG.
        f2: {f3()} -> {f4()}
            - same as above, except now only asserting on CFG nodes under `f2()`

    Notice how assertions for `c -> d` and `b -> c` aren't needed, since they are satisfied by assertions on calling `f3` and `f4`
    (for example, if f2 calls f3, then f2 is *guaranteed* to reach `b -> c` in the call).
    On the other hand, simply asserting that `f1` can call `f2` after `a -> b` but before `d -> e`
    is not enough, since within `f2` it must simultaneously be true that `f3` is called before `f4`, otherwise the dataflow chain is invalid.

    As such, there emerges a pattern: if a function `foo` links only one node, as do `f3` and `f4`, then they don't require internal CFG constraints.
    Otherwise, there must exist a path within `foo` that visits its internal `varWrite` nodes and `call` nodes in the correct order.


    The algorithm builds up the above assertions by maintaining a "parallel" list of function call sequences. As soon as one sequence
    contains a feasible path, the entire varWrite* path is deemed valid.

        To model a particular sequence, keep track of a call stack, and a list of popped frames.

                Consider this dummy snapshot:

                popped frames: []
                s#n:[ fn1:{v1 -> v2} -> {fn2()},
                      fn2:{v2 -> v3} -> {v3 -> v4} -> {fn3()},
                      fn3:{v4 -> v5} ]

                The popped list is empty, but the call stack has already tracked fn1 -> fn2 -> fn3.

                Now, let's say we are trying to see if `fn5`, which contains `v5 -> v6` can be reached.

                    Does fn3 transitively call fn5? Suppose no.
                    As explained above, a function with just one node doesn't need an explicit query, so the popped assertions
                    list remains empty.

                    Does fn2 transitively call fn5? Suppose no.
                    fn2 is popped, but now we add to the final list of popped frames:
                        popped frames: [ fn2:{v2 -> v3} -> {v3 -> v4} -> {fn3()} ]

                    Does fn1 transitively call fn5? Suppose yes, with call chain fn1 -> f4 -> fn5. Then we add the call chain to the stack:

                    popped frames: [ fn2:{v2 -> v3} -> {v3 -> v4} -> {fn3()} ]
                    s#n:[ fn1:{v1 -> v2} -> {fn2()} -> {fn4()},
                          fn4:{fn5()},
                          fn5:{v5 -> v6} ]

                Now, we are on the final varWrite: v6 -> v7 in function fn6. The above process is repeated:

                    Does fn5 call fn6? Suppose it calls it directly fn5 -> fn6. So we add fn6 to the stack:

                    popped frames: [ fn2:{v2 -> v3} -> {v3 -> v4} -> {fn3()} ]
                    s#n:[ fn1:{v1 -> v2} -> {fn2()} -> {fn4()},
                          fn4:{fn5()},
                          fn5:{v5 -> v6} -> {fn6()},
                          fn6:{v6 -> v7} ]

                    TODO: { currently, the algorithm stops popping the stack as soon as the top either is, or transitively calls the function
                    being searched for (fn6 in this case). However, this may miss some false positives. Say that fn5 actually
                    calls fn6() *before* its `v5 -> v6` relation. Then the CFG assertion inside it will fail and thus the validator
                    will say that the entire varWrite* path is a false positive. However, what if after fn5 returns, fn4 calls fn6 right after it?
                    This second call to fn6 is missed. This failure case was caught late, and so it wasn't implemented.
                        Test cases for it should capture the example described, as well as stuff like:

                            void bar() {
                                c = b;
                                b = a;
                            }
                            void foo() {
                                bar();
                                bar();
                            }

                            ^^ this suffers from the same problem:
                            stack: [ foo: {bar()}
                                     bar: {a -> b} ]
                                now to reach {b -> c}, we look at the top entry of the stack, and it's already bar, but {a -> b} can't directly
                                reach {b -> c} within bar, so we mark the path {a -> b -> c} as a false positive. However, there is a second call
                                to bar() within foo that makes the path feasible!
                    }

                    With the entire path complete, the stack can now be fully popped, and the queries run. If they are all true, the path is valid.
                    Otherwise, it is a false positive.

                    popped frames: [ fn2:{v2 -> v3} -> {v3 -> v4} -> {fn3()},
                                     fn5:{v5 -> v6} -> {fn6()},
                                     fn1:{v1 -> v2} -> {fn2()} -> {fn4()} ]

"""

from neo4j import GraphDatabase
import sys
import random
import csv

uri = "bolt://localhost:7687"
username = "neo4j"
password = 123

global _session
def setSession(session):
    global _session
    _session = session

class StackFrame:

    def __init__(self, fnID):
        self.fnID = fnID
        self.stepCount = 0
        self.match = ""
        self.pattern = ""
        self.whereID = ""

    def addStep(self, CFGIDs):
        self.stepCount += 1

        if self.stepCount != 1:
            self.match += ", "
            """
            TODO: Due to the current implementation of CFG block decomposition, a single CFG block may contain valid
                  transitive writes. So for now, add `contain*0..`, even though this also exposes the potential for false
                  positives to seep through.
                  See Rex documentation about CFG block decomposition for more details.
            """
            self.pattern += "-[:contain*0..]->"
            self.whereID += " and "

        nodeName = "n" + str(self.stepCount)
        self.match += "(" + nodeName + ")"
        self.pattern += "(" + nodeName + ")"
        self.whereID += nodeName + ".id in " + str(CFGIDs)

    def empty(self):
        return self.stepCount == 1

    """
    match (n1), (n2), ..., (nm)
    where n1.id in {CFGs} and n2.id in {CFGs} and ... and (n1)-[:contain*0..]->(n2)-...-[:contain*0..]->(nm)
    """
    def getQuery(self):
        return "match " + self.match + " where " + self.whereID + " and " + self.pattern + " return 1 limit 1"

    def __str__(self):
        return "StackFrame:" + self.fnID + "=" + self.getQuery()
    def __repr__(self):
        return str(self)

# Returns the locations of function calls along all path of function calls between src and dst
#
# bar() {
#     baz();
# }
# foo() {
#     bar();
#     baz();
#     bar();
# }
#
# If we query for all paths from `foo` to `baz`, then there are 2 distinct paths:
# (1) `foo -> baz` and
#     returns 1 row: g=baz, cfgs=<location of baz() call in side foo()
# (2) `foo -> bar -> baz`
#     returns 2 rows:
#         1. g=bar, cfgs=<both locations of bar() call inside foo()
#         2. g=baz, cfrs=<location of baz() call inside bar()
#
# So this function will return two paths, ordered in increasing length
# [
#     [("baz", [cfgs...])],                    # corresponds to result (1)
#     [("bar", [cfgs...]), ("baz", [cfgs...])] # corresponds to result (2)
# ]
#
# Note: don't need to use a "restricted" version of the callpairs relationship here because by definition,
# we are restricting based on transitive calls (If this changes in the future, will need to update)

def getCallChains(srcID, dstID):
    global _session
    result = _session.run("""
    match p=(:cFunction{id:$src})
        -[:edgeLink]->(:callNode)-[:callpair*0..]->(:callNode)-[:edgeLink]->(:cFunction{id:$dst})
    with *, [n in nodes(p) where "callNode" in labels(n) | n] as callNodes
    unwind callNodes as call
    match (g:cFunction)<-[:edgeLink]-(call)-[:cfgLink]->(cfg)
    return p, g.id as g, [c in collect(cfg) | c.id] as cfgs
    order by length(p)
    """, src=srcID, dst=dstID)

    curP = None
    ret = []
    for r in result:
        p = r['p']
        if p != curP: # the results in the query are grouped by `p`
            curP = p
            ret.append([])

        ret[-1].append((r['g'], r['cfgs']))

    return ret


# return a dict of:
# {
#    <function which contains varWriteNode>:
#       [<cfg corresponding to varWriteNode that is also in the function>],
#   ...
# }
# Note: all location edges use the restricted versions, so as to only return results that are within the bounds
# of the paths being analyzed
def getLocationInfo(varWriteNodeID):
    global _session
    result = _session.run("""
    match (v:varWriteNode{id:$id})<-[:restrictedContain]-(f:cFunction)
    with *, [(v)-[:cfgLink]->(cfg)<-[:contain]-(f) | cfg.id] as cfgs
    return f.id as f, cfgs
    """, id=varWriteNodeID)
    ret = {}
    for row in result:
        ret[row['f']] = row['cfgs']
    return ret

# path is a list of consecutive `getLocationInfo` results, with each result being generated from a node
# along that path
def validatePath(path):

    def workOnNextRelation(stack, queries, remainingRels):
        nextRel = remainingRels[0]

        for fn, cfgs in nextRel.items():
            if doWork(stack.copy(), queries.copy(), fn, cfgs, nextRel, remainingRels[1:]):
                return True

        return False

    def doWork(stack, queries, fnID, CFGs, curRel, remainingRels):

        branches = []
        if len(stack) != 0:
            callChains = []
            # find closest ancestor
            while len(stack) != 0:
                if stack[-1].fnID == fnID:
                    break
                callChains = getCallChains(stack[-1].fnID, fnID)
                if len(callChains) != 0:
                    break

                # the top of the stack does not lead to `fnID`, pop it
                if not stack[-1].empty():
                    queries.append(stack[-1].getQuery())
                stack.pop()

            if len(stack) == 0:
                # the stack has been fully popped, meaning there was no ancestor
                # that is/calls `fnID`. The path is invalid.
                return False

            # branch per callchain
            if len(callChains) != 0:
                trunk = stack
                for callChain in callChains:
                    branch = trunk.copy()
                    for (calledFunc, callCFGs) in callChain:
                        branch[-1].addStep(callCFGs)
                        branch.append(StackFrame(calledFunc))

                    branches.append(branch)
            else:
                branches = [stack]
        else:
            branches = [[StackFrame(fnID)]]

        # At this point, the top of each stack (branch) is fnID
        for branch in branches:
            branch[-1].addStep(CFGs)

            """
            TODO: It might be prudent to run the assertion for branch[-1] at this point, since the added step may be infeasible.
            However, it is not 100% obvious if this short-circuiting would speed up the algorithm, since we would end up running more queries
            If the structure of the source code results in many branches, with many branches being infeasible, then it would
            probably be better to short-circuit so that the total # of branches stay small. If there are many branches but most tend to be
            feasible, then it's probably better to wait until a valid branch is found, since the algorithm **does** short-circuit as
            soon as a valid branch is found, and this would result in just one big query for the valid stack, as opposed to constantly
            checking the increments.
            If there are few branches, then it would still depend on how long the branches tend to get...
              Some more thought is needed...
            """

            # The path is done, run the queries
            if len(remainingRels) == 0:

                while len(branch) != 0:
                    if not branch[-1].empty():
                        queries.append(branch[-1].getQuery())
                    branch.pop()

                if len(queries) == 0:
                    raise "SOMETHING IS SUPER WRONG"

                # Take conjunction of queries
                badBranch = False
                for q in queries:
                    result = _session.run(q)
                    if result.peek() is None:
                        badBranch = True
                        break
                if badBranch:
                    continue

                # The path is valid, short-circuit
                return True
            else: # process the next node in the path
                if workOnNextRelation(branch, queries, remainingRels):
                    return True

        # None of the branches could support the path. It is invalid
        return False

    return workOnNextRelation([], [], path)

